package endpoints

import (
	"encoding/hex"
	"encoding/json"
	"math/big"
	"net/http"

	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/rlp"
	"github.com/gorilla/mux"

	// "github.com/tomochain/backend-matching-engine/contracts/contractsinterfaces"

	"github.com/tomochain/backend-matching-engine/contracts"
	"github.com/tomochain/backend-matching-engine/contracts/contractsinterfaces"
	"github.com/tomochain/backend-matching-engine/errors"
	"github.com/tomochain/backend-matching-engine/interfaces"
	"github.com/tomochain/backend-matching-engine/swap"
	"github.com/tomochain/backend-matching-engine/swap/ethereum"
	"github.com/tomochain/backend-matching-engine/types"
	"github.com/tomochain/backend-matching-engine/utils/httputils"
)

type depositEndpoint struct {
	depositService interfaces.DepositService
	walletService  interfaces.WalletService
	txService      interfaces.TxService
}

func ServeDepositResource(
	r *mux.Router,
	depositService interfaces.DepositService,
	walletService interfaces.WalletService,
	txService interfaces.TxService,
) {

	e := &depositEndpoint{depositService, walletService, txService}
	r.HandleFunc("/deposit/schema", e.handleGetSchema).Methods("GET")
	r.HandleFunc("/deposit/generate-address", e.handleGenerateAddress).Methods("POST")
	r.HandleFunc("/deposit/recovery-transaction", e.handleRecoveryTransaction).Methods("GET")

	// set event handler delegate to this service
	depositService.SetDelegate(e)
}

func (e *depositEndpoint) handleGetSchema(w http.ResponseWriter, r *http.Request) {
	schemaVersion := e.depositService.GetSchemaVersion()
	schema := map[string]interface{}{
		"version": schemaVersion,
	}
	httputils.WriteJSON(w, http.StatusOK, schema)
}

func (e *depositEndpoint) handleGenerateAddress(w http.ResponseWriter, r *http.Request) {
	v := r.URL.Query()
	chainStr := v.Get("chain")
	addr := v.Get("userAddress")

	pairAddresses := &types.PairAddresses{}

	decoder := json.NewDecoder(r.Body)
	err := decoder.Decode(pairAddresses)
	if err != nil {
		httputils.WriteError(w, http.StatusBadRequest, "Invalid pair addresses")
		return
	}
	defer r.Body.Close()

	if addr == "" {
		httputils.WriteError(w, http.StatusBadRequest, "address Parameter missing")
		return
	}

	if !common.IsHexAddress(addr) {
		httputils.WriteError(w, http.StatusBadRequest, "Invalid User Address")
		return
	}

	associatedAddress := common.HexToAddress(addr)

	var chain types.Chain
	err = chain.Scan([]byte(chainStr))
	if err != nil {
		logger.Error(err)
		httputils.WriteError(w, http.StatusInternalServerError, "Chain is not correct")
		return
	}
	address, err := e.depositService.GenerateAddress(chain)

	if err != nil {
		logger.Error(err)
		httputils.WriteError(w, http.StatusInternalServerError, "Can not generate Address")
		return
	}

	// update association, client should update as well in swarm feed
	// after receiving and displaying the address generated by server
	err = e.depositService.SaveAssociationByChainAddress(chain, address, associatedAddress, pairAddresses)
	if err != nil {
		logger.Error(err)
		httputils.WriteError(w, http.StatusInternalServerError, "Can not save association")
		return
	}

	response := types.GenerateAddressResponse{
		ProtocolVersion: swap.ProtocolVersion,
		Chain:           chain.String(),
		Address:         address.Hex(),
		Signer:          e.depositService.SignerPublicKey().Hex(),
	}

	httputils.WriteJSON(w, http.StatusOK, response)
}

// return Address association for testing first
func (e *depositEndpoint) handleRecoveryTransaction(w http.ResponseWriter, r *http.Request) {
	v := r.URL.Query()
	addr := v.Get("userAddress")
	chainStr := v.Get("chain")
	var chain types.Chain
	err := chain.Scan([]byte(chainStr))
	if err != nil {
		logger.Error(err)
		httputils.WriteError(w, http.StatusInternalServerError, "Chain is not correct")
		return
	}

	if addr == "" {
		httputils.WriteError(w, http.StatusBadRequest, "address Parameter missing")
		return
	}

	if !common.IsHexAddress(addr) {
		httputils.WriteError(w, http.StatusBadRequest, "Invalid User Address")
		return
	}

	address := common.HexToAddress(addr)

	association, err := e.depositService.GetAssociationByTomochainPublicKey(chain, address)
	// association, err := e.depositService.GetAssociationByChainAddress(chain, address)

	if err != nil {
		logger.Error(err)
		httputils.WriteError(w, http.StatusInternalServerError, "Can not get address association")
		return
	}

	httputils.WriteJSON(w, http.StatusOK, association)
}

/***** events from engine ****/
// onNewEthereumTransaction checks if transaction is valid and adds it to
// the transactions queue for TomochainAccountConfigurator to consume.
//
// Transaction added to transactions queue should be in a format described in
// types.DepositTransaction (especialy amounts). Pooling service should not have to deal with any
// conversions.
func (e *depositEndpoint) OnNewEthereumTransaction(transaction ethereum.Transaction) error {
	logger.Infof("Processing transaction: %v", transaction)

	// Let's check if tx is valid first.

	// Check if value is above minimum required
	if transaction.ValueWei.Cmp(e.depositService.MinimumValueWei()) < 0 {
		logger.Debug("Value is below minimum required amount, skipping")
		return nil
	}

	addressTo := common.HexToAddress(transaction.To)

	addressAssociation, err := e.depositService.GetAssociationByChainAddress(types.ChainEthereum, addressTo)

	if err != nil {
		logger.Errorf("Chain: %s, Got error: %v", types.ChainEthereum, err)
		return nil
	}

	logger.Infof("Got Association: %v", addressAssociation)

	// Add tx to the processing queue
	queueTx := &types.DepositTransaction{
		Chain:         types.ChainEthereum,
		TransactionID: transaction.Hash,
		AssetCode:     types.AssetCodeETH,
		// Amount in the base unit of currency.
		Amount:             transaction.ValueWei.String(),
		TomochainPublicKey: addressAssociation.AssociatedAddress,
	}

	// Add transaction as processing. this should be end point or tokenService
	// if have many nodes, should use queue instead

	if addressAssociation.Status == "PENDING" || addressAssociation.Status == "SUCCESS" {
		// is processing or processed, just skip
		logger.Debug("Transaction already processed, skipping")
		return nil
	}

	err = e.processTransaction(addressAssociation, transaction.ValueWei)
	if err != nil {
		return err
	}

	// add queue transaction
	err = e.depositService.QueueAdd(queueTx)
	if err != nil {
		return errors.Wrap(err, "Error adding transaction to the processing queue")
	}

	logger.Info("Transaction added to transaction queue: %v", queueTx)

	// Broadcast event to address stream using websocket
	logger.Infof("Broadcasting event: %v", transaction)
	logger.Info("Transaction processed successfully")
	return nil
}

func (e *depositEndpoint) OnSubmitTransaction(chain types.Chain, destination string, associationTransaction *types.AssociationTransaction) error {

	// Save tx to database
	publicKey := common.HexToAddress(destination)

	bytes, err := rlp.EncodeToBytes(associationTransaction)
	if err != nil {
		logger.Error("Error encode transaction to string")
		return err
	}

	transaction := hex.EncodeToString(bytes)

	err = e.depositService.SaveDepositTransaction(chain, publicKey, transaction)
	if err != nil {
		logger.Error("Error saving transaction to DB")
		return err
	}
	return nil
}

func (e *depositEndpoint) OnTomochainAccountCreated(chain types.Chain, destination string) {
	publicKey := common.HexToAddress(destination)
	association, err := e.depositService.GetAssociationByTomochainPublicKey(chain, publicKey)
	if err != nil {
		logger.Error("Error getting association")
		return
	}

	if association == nil {
		logger.Error("Association not found")
		return
	}
	// broast cast event association
	logger.Infof("Broasting event: %v", association)
}

func (e *depositEndpoint) OnExchanged(chain types.Chain, destination string) {
	publicKey := common.HexToAddress(destination)
	association, err := e.depositService.GetAssociationByTomochainPublicKey(chain, publicKey)
	if err != nil {
		logger.Error("Error getting association")
		return
	}

	if association == nil {
		logger.Error("Association not found")
		return
	}

	logger.Infof("Broasting event: %v", association)
}

func (e *depositEndpoint) OnExchangedTimelocked(chain types.Chain, destination string, associationTransaction *types.AssociationTransaction) {
	publicKey := common.HexToAddress(destination)
	association, err := e.depositService.GetAssociationByTomochainPublicKey(chain, publicKey)
	if err != nil {
		logger.Error("Error getting association")
		return
	}

	if association == nil {
		logger.Error("Association not found")
		return
	}

	// Save tx to database
	bytes, err := rlp.EncodeToBytes(associationTransaction)
	if err != nil {
		logger.Error("Error encode transaction to string")
		return
	}

	transaction := hex.EncodeToString(bytes)
	err = e.depositService.SaveDepositTransaction(chain, publicKey, transaction)
	if err != nil {
		logger.Error("Error saving unlock transaction to DB")
		return
	}

	logger.Infof("Broasting event: %v", association)
}

func (e *depositEndpoint) LoadAccountHandler(chain types.Chain, destination string) (*types.AddressAssociation, error) {
	publicKey := common.HexToAddress(destination)
	return e.depositService.GetAssociationByTomochainPublicKey(chain, publicKey)
}

func (e *depositEndpoint) processTransaction(addressAssociation *types.AddressAssociationRecord, quoteAmount *big.Int) error {

	// update status is pending, if is pending or success then return true, to tell it stop
	// otherwise return false, then update the status is pending, on success update it success,
	// on faile update it fail, so next time it will return false again to re-process
	// default contractAddress is e.depositService.WethAddress(),
	// call smart contract and listen to event, then update to mongodb via DAO

	contractAddress := common.HexToAddress(addressAssociation.BaseTokenAddress)
	chain := types.NewChain(addressAssociation.Chain)
	address := common.HexToAddress(addressAssociation.Address)
	receiver := common.HexToAddress(addressAssociation.AssociatedAddress)

	token, err := contracts.NewToken(
		e.walletService, e.txService,
		contractAddress,
		e.depositService.EthereumClient())

	if err != nil {
		e.depositService.SaveAssociationStatusByChainAddress(chain, address, "FAILED")
		return errors.Errorf("Could not connect to token address: %s", err.Error())
	}

	logs := []*contractsinterfaces.TokenTransfer{}

	// now calculate tokenAmount
	tokenAmount, err := e.depositService.GetBaseTokenAmount(addressAssociation.PairName, quoteAmount)

	if err != nil {
		e.depositService.SaveAssociationStatusByChainAddress(chain, address, "FAILED")
		return errors.Errorf("Could not convert to token amount to transfer: %s", err.Error())
	}

	done := make(chan bool)

	events, err := token.ListenToTransferEvents()
	if err != nil {
		e.depositService.SaveAssociationStatusByChainAddress(chain, address, "FAILED")
		return errors.Errorf("Could not open transfer events channel")
	}

	go func() {
		for {
			event := <-events
			logs = append(logs, event)
			done <- true
		}
	}()

	_, err = token.Transfer(receiver, tokenAmount)
	if err != nil {
		e.depositService.SaveAssociationStatusByChainAddress(chain, address, "FAILED")
		return errors.Errorf("Could not transfer tokens: %v", err)
	}

	<-done

	if len(logs) != 1 {
		e.depositService.SaveAssociationStatusByChainAddress(chain, address, "FAILED")
		return errors.Errorf("Events log has not the correct length")
	}

	parsedTransfer := logs[0]

	if parsedTransfer.To != receiver {
		e.depositService.SaveAssociationStatusByChainAddress(chain, address, "FAILED")
		return errors.Errorf("Event 'To' field is not correct")
	}
	if parsedTransfer.Value.Cmp(tokenAmount) != 0 {
		e.depositService.SaveAssociationStatusByChainAddress(chain, address, "FAILED")
		return errors.Errorf("Event 'Amount' field is not correct")
	}

	e.depositService.SaveAssociationStatusByChainAddress(chain, address, "SUCCESS")
	// just done processing, continue to broadcast
	return nil
}
