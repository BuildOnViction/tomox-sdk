package endpoints

import (
	"math/big"
	"net/http"

	"github.com/ethereum/go-ethereum/common"
	"github.com/gorilla/mux"

	// "github.com/tomochain/backend-matching-engine/contracts/contractsinterfaces"
	"github.com/tomochain/backend-matching-engine/contracts"
	"github.com/tomochain/backend-matching-engine/contracts/contractsinterfaces"
	"github.com/tomochain/backend-matching-engine/errors"
	"github.com/tomochain/backend-matching-engine/interfaces"
	"github.com/tomochain/backend-matching-engine/swap"
	"github.com/tomochain/backend-matching-engine/swap/ethereum"
	"github.com/tomochain/backend-matching-engine/swap/queue"
	"github.com/tomochain/backend-matching-engine/types"
	"github.com/tomochain/backend-matching-engine/utils/httputils"
)

type depositEndpoint struct {
	depositService interfaces.DepositService
	walletService  interfaces.WalletService
	txService      interfaces.TxService
}

func ServeDepositResource(
	r *mux.Router,
	depositService interfaces.DepositService,
	walletService interfaces.WalletService,
	txService interfaces.TxService,
) {

	e := &depositEndpoint{depositService, walletService, txService}
	r.HandleFunc("/deposit/schema", e.handleGetSchema).Methods("GET")
	r.HandleFunc("/deposit/generate-address", e.handleGenerateAddress).Methods("GET")
	r.HandleFunc("/deposit/recovery-transaction", e.handleRecoveryTransaction).Methods("GET")

	// set event handler delegate to this service
	depositService.SetDelegate(e)
}

func (e *depositEndpoint) handleGetSchema(w http.ResponseWriter, r *http.Request) {
	schemaVersion := e.depositService.GetSchemaVersion()
	schema := map[string]interface{}{
		"version": schemaVersion,
	}
	httputils.WriteJSON(w, http.StatusOK, schema)
}

func (e *depositEndpoint) handleGenerateAddress(w http.ResponseWriter, r *http.Request) {
	v := r.URL.Query()
	chainStr := v.Get("chain")
	addr := v.Get("userAddress")

	if addr == "" {
		httputils.WriteError(w, http.StatusBadRequest, "address Parameter missing")
		return
	}

	if !common.IsHexAddress(addr) {
		httputils.WriteError(w, http.StatusBadRequest, "Invalid User Address")
		return
	}

	associatedAddress := common.HexToAddress(addr)

	var chain types.Chain
	err := chain.Scan([]byte(chainStr))
	if err != nil {
		logger.Error(err)
		httputils.WriteError(w, http.StatusInternalServerError, "Chain is not correct")
		return
	}
	address, err := e.depositService.GenerateAddress(chain)

	if err != nil {
		logger.Error(err)
		httputils.WriteError(w, http.StatusInternalServerError, "Can not generate Address")
		return
	}

	// update association, client should update as well in swarm feed
	// after receiving and displaying the address generated by server
	err = e.depositService.SaveAssociationByChainAddress(chain, address, associatedAddress)
	if err != nil {
		logger.Error(err)
		httputils.WriteError(w, http.StatusInternalServerError, "Can not save association")
		return
	}

	response := types.GenerateAddressResponse{
		ProtocolVersion: swap.ProtocolVersion,
		Chain:           chain.String(),
		Address:         address.Hex(),
		Signer:          e.depositService.SignerPublicKey().Hex(),
	}

	httputils.WriteJSON(w, http.StatusOK, response)
}

// return Address association for testing first
func (e *depositEndpoint) handleRecoveryTransaction(w http.ResponseWriter, r *http.Request) {
	v := r.URL.Query()
	addr := v.Get("userAddress")
	chainStr := v.Get("chain")
	var chain types.Chain
	err := chain.Scan([]byte(chainStr))
	if err != nil {
		logger.Error(err)
		httputils.WriteError(w, http.StatusInternalServerError, "Chain is not correct")
		return
	}

	if addr == "" {
		httputils.WriteError(w, http.StatusBadRequest, "address Parameter missing")
		return
	}

	if !common.IsHexAddress(addr) {
		httputils.WriteError(w, http.StatusBadRequest, "Invalid User Address")
		return
	}

	address := common.HexToAddress(addr)

	association, err := e.depositService.GetAssociationByTomochainPublicKey(chain, address)
	// association, err := e.depositService.GetAssociationByChainAddress(chain, address)

	if err != nil {
		logger.Error(err)
		httputils.WriteError(w, http.StatusInternalServerError, "Can not get address association")
		return
	}

	httputils.WriteJSON(w, http.StatusOK, association)
}

/***** events from engine ****/
// onNewEthereumTransaction checks if transaction is valid and adds it to
// the transactions queue for TomochainAccountConfigurator to consume.
//
// Transaction added to transactions queue should be in a format described in
// queue.Transaction (especialy amounts). Pooling service should not have to deal with any
// conversions.
func (e *depositEndpoint) OnNewEthereumTransaction(transaction ethereum.Transaction) error {
	logger.Info("Processing transaction: %v", transaction)

	// Let's check if tx is valid first.

	// Check if value is above minimum required
	if transaction.ValueWei.Cmp(e.depositService.MinimumValueWei()) < 0 {
		logger.Debug("Value is below minimum required amount, skipping")
		return nil
	}

	addressTo := common.HexToAddress(transaction.To)

	addressAssociation, err := e.depositService.GetAssociationByChainAddress(types.ChainEthereum, addressTo)

	logger.Infof("Got Association: %v", addressAssociation)

	if err != nil {
		logger.Errorf("Chain: %s, Address to send token: %s, Got error: %v", types.ChainEthereum, addressTo.String(), err)
		return errors.Wrap(err, "Error getting association")
	}

	if addressAssociation == nil {
		logger.Debug("Associated address not found, skipping")
		return nil
	}

	// Add tx to the processing queue
	queueTx := &queue.Transaction{
		TransactionID: transaction.Hash,
		AssetCode:     queue.AssetCodeETH,
		// Amount in the base unit of currency.
		Amount:             transaction.ValueWei.String(),
		TomochainPublicKey: addressAssociation.AssociatedAddress,
	}

	// Add transaction as processing. this should be end point or tokenService
	// if have many nodes, should use queue instead
	processed, err := e.processedTransaction(queueTx)
	if err != nil {
		return err
	}

	if processed {
		logger.Debug("Transaction already processed, skipping")
		return nil
	}

	// err = s.swapEngine.TransactionsQueue().QueueAdd(queueTx)
	// if err != nil {
	// 	return errors.Wrap(err, "Error adding transaction to the processing queue")
	// }
	logger.Info("Transaction added to transaction queue: %v", queueTx)

	// Broadcast event to address stream using websocket
	logger.Infof("Broadcasting event: %v", transaction)
	logger.Info("Transaction processed successfully")
	return nil
}

func (e *depositEndpoint) OnTomochainAccountCreated(destination string) {
	publicKey := common.HexToAddress(destination)
	association, err := e.getAssociationByTomochainPublicKey(publicKey)
	if err != nil {
		logger.Error("Error getting association")
		return
	}

	if association == nil {
		logger.Error("Association not found")
		return
	}
	// broast cast event association
	logger.Infof("Broasting event: %v", association)
}

func (e *depositEndpoint) OnExchanged(destination string) {
	publicKey := common.HexToAddress(destination)
	association, err := e.getAssociationByTomochainPublicKey(publicKey)
	if err != nil {
		logger.Error("Error getting association")
		return
	}

	if association == nil {
		logger.Error("Association not found")
		return
	}

	logger.Infof("Broasting event: %v", association)
}

func (e *depositEndpoint) OnExchangedTimelocked(destination, transaction string) {
	publicKey := common.HexToAddress(destination)
	association, err := e.getAssociationByTomochainPublicKey(publicKey)
	if err != nil {
		logger.Error("Error getting association")
		return
	}

	if association == nil {
		logger.Error("Association not found")
		return
	}

	// Save tx to database
	err = e.addRecoveryTransaction(publicKey, transaction)
	if err != nil {
		logger.Error("Error saving unlock transaction to DB")
		return
	}

	logger.Infof("Broasting event: %v", association)
}

func (e *depositEndpoint) processedTransaction(transaction *queue.Transaction) (bool, error) {
	// call smart contract and listen to event, then update to mongodb via DAO
	token, err := contracts.NewToken(
		e.walletService, e.txService,
		e.depositService.WethAddress(),
		e.depositService.EthereumClient())

	if err != nil {
		return false, errors.Errorf("Could not connect to token address: %s", err.Error())
	}

	logs := []*contractsinterfaces.TokenTransfer{}

	transferAmount := new(big.Int)
	transferAmount, ok := transferAmount.SetString(transaction.Amount, 10)

	if !ok {
		return false, errors.Errorf("Could not convert amount :%v", transaction.Amount)
	}

	done := make(chan bool)

	events, err := token.ListenToTransferEvents()
	if err != nil {
		return false, errors.Errorf("Could not open transfer events channel")
	}

	go func() {
		for {
			event := <-events
			logs = append(logs, event)
			done <- true
		}
	}()

	receiver := common.HexToAddress(transaction.TomochainPublicKey)

	_, err = token.Transfer(receiver, transferAmount)
	if err != nil {
		return false, errors.Errorf("Could not transfer tokens: %v", err)
	}

	<-done

	if len(logs) != 1 {
		return false, errors.Errorf("Events log has not the correct length")
	}

	parsedTransfer := logs[0]

	if parsedTransfer.To != receiver {
		return false, errors.Errorf("Event 'To' field is not correct")
	}
	if parsedTransfer.Value.Cmp(transferAmount) != 0 {
		return false, errors.Errorf("Event 'Amount' field is not correct")
	}

	return true, nil
}

func (e *depositEndpoint) getAssociationByTomochainPublicKey(tomochainPublicKey common.Address) (*types.AddressAssociation, error) {
	return nil, nil
}

func (e *depositEndpoint) addRecoveryTransaction(sourceAccount common.Address, txEnvelope string) error {
	return nil
}
